package problem

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// ContentTypeJSON https://tools.ietf.org/html/rfc9457#section-6.1
const ContentTypeJson = "application/problem+json"

// Problem is an RFC7807 error and can be compared with errors.Is().
type Problem struct {
	data   map[string]any
	reason error
}

// JSON returns the Problem as json bytes.
func (p Problem) JSON() []byte {
	b, _ := p.MarshalJSON()
	return b
}

func (p Problem) Problem() Problem {
	return p
}

// UnmarshalJSON implements the json.Unmarshaler interface.
func (p Problem) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &p.data)
}

// MarshalJSON implements the json.Marshaler interface.
func (p Problem) MarshalJSON() ([]byte, error) {
	return json.Marshal(&p.data)
}

// JSONString returns the Problem as json string.
func (p Problem) JSONString() string {
	return string(p.JSON())
}

// Error implements the error interface, so a Problem can be used as an error.
func (p Problem) Error() string {
	return p.JSONString()
}

// Is compares Problem.Error() with err.Error().
func (p Problem) Is(err error) bool {
	return p.Error() == err.Error()
}

// Unwrap returns the result of calling the Unwrap method on err, if err implements Unwrap.
// Otherwise, Unwrap returns nil.
func (p Problem) Unwrap() error {
	return p.reason
}

// WriteHeaderTo writes the HTTP headers for the JSON Problem ContentType and the
// problem's HTTP status code. THis is suitable for responding to HEAD requests.
func (p Problem) WriteHeaderTo(w http.ResponseWriter) {
	w.Header().Set("Content-Type", ContentTypeJson)
	if statusCode, ok := p.data["status"]; ok {
		if statusInt, ok := statusCode.(int); ok {
			w.WriteHeader(statusInt)
		}
	}
}

// WriteTo writes the JSON Problem to an HTTP Response Writer using the correct
// Content-Type and the problem's HTTP status code.
func (p Problem) WriteTo(w http.ResponseWriter) (int, error) {
	p.WriteHeaderTo(w)
	return w.Write(p.JSON())
}

// Append an Option to a existing Problem
func (p *Problem) Append(opts ...option) *Problem {
	for _, opt := range opts {
		opt.apply(p)
	}
	return p
}

// StatusCode returns the HTTP status code of the Problem
func (p *Problem) StatusCode() int {
	if status, ok := p.data["status"]; ok {
		if statusInt, ok := status.(int); ok {
			return statusInt
		}
	}

	return http.StatusInternalServerError
}

// New generates a new Problem
func New(opts ...option) *Problem {
	problem := &Problem{}
	problem.data = make(map[string]any)
	return problem.Append(opts...)
}

// Of creates a Problem based on status code with Title and Type automatically set
func Of(statusCode int) *Problem {
	return New(
		WithStatus(statusCode),
		WithTitle(http.StatusText(statusCode)),
		WithType(getTypeUri(statusCode)),
	)
}

// Wrap an error to the Problem
func Wrap(err error) option {
	return optionFunc(func(p *Problem) {
		p.reason = err
		p.data["reason"] = err.Error()
	})
}

// WrapSilent wraps an error inside of the Problem without placing the wrapped
// error into the problem's JSON body. Useful for cases where the underlying
// error needs to be preserved but not transmitted to the user.
func WrapSilent(err error) option {
	return optionFunc(func(p *Problem) {
		p.reason = err
	})
}

// WithType sets the type URI (typically, with "http" or "https" scheme) that identifies the problem type.
// When dereferenced, it SHOULD provide human-readable documentation of the problem type.
func WithType(uri string) option {
	return optionFunc(func(p *Problem) {
		p.data["type"] = uri
	})
}

// WithTitle sets a title that appropriately describes it (think short)
// Written in English and readable for engineers (usually not suited for
// non technical stakeholders and not localized).
// example - Service Unavailable
func WithTitle(title string) option {
	return optionFunc(func(p *Problem) {
		p.data["title"] = title
	})
}

// WithTitlef sets a title using a format string that appropriately describes it (think short)
// Written in English and readable for engineers (usually not suited for
// non technical stakeholders and not localized).
// example - Service Unavailable
func WithTitlef(format string, values ...any) option {
	return WithTitle(fmt.Sprintf(format, values...))
}

// WithStatus sets the HTTP status code generated by the origin server for this
// occurrence of the problem.
func WithStatus(status int) option {
	return optionFunc(func(p *Problem) {
		p.data["status"] = status
	})
}

// Detail a human readable explanation specific to this occurrence of the problem.
func WithDetail(detail string) option {
	return optionFunc(func(p *Problem) {
		p.data["detail"] = detail
	})
}

// WithDetailf a human readable explanation using a format string specific to this occurrence of the problem.
func WithDetailf(format string, values ...any) option {
	return WithDetail(fmt.Sprintf(format, values...))
}

// WithInstance an absolute URI that identifies the specific occurrence of the problem.
func WithInstance(uri string) option {
	return optionFunc(func(p *Problem) {
		p.data["instance"] = uri
	})
}

// WithInstancef an absolute URI using a format string that identifies the specific occurrence of the problem.
func WithInstancef(format string, values ...any) option {
	return WithInstance(fmt.Sprintf(format, values...))
}

// WithCustom sets a custom key value
func WithCustom[T any](key string, value T) option {
	return optionFunc(func(p *Problem) {
		p.data[key] = value
	})
}

// getTypeUri returns the URI for the RFC7231 section for the given status code
func getTypeUri(statusCode int) string {
	codeSection := map[int]string{
		100: "15.2.1",
		101: "15.2.2",
		200: "15.3.1",
		201: "15.3.2",
		202: "15.3.3",
		203: "15.3.4",
		204: "15.3.5",
		205: "15.3.6",
		206: "15.3.7",
		300: "15.4.1",
		301: "15.4.2",
		302: "15.4.3",
		303: "15.4.4",
		304: "15.4.5",
		305: "15.4.6",
		306: "15.4.7",
		307: "15.4.8",
		308: "15.4.9",
		400: "15.5.1",
		401: "15.5.2",
		402: "15.5.3",
		403: "15.5.4",
		404: "15.5.5",
		405: "15.5.6",
		406: "15.5.7",
		407: "15.5.8",
		408: "15.5.9",
		409: "15.5.10",
		410: "15.5.11",
		411: "15.5.12",
		412: "15.5.13",
		413: "15.5.14",
		414: "15.5.15",
		415: "15.5.16",
		416: "15.5.17",
		417: "15.5.18",
		418: "15.5.19",
		421: "15.5.20",
		422: "15.5.21",
		426: "15.5.22",
		500: "15.6.1",
		501: "15.6.2",
		502: "15.6.3",
		503: "15.6.4",
		504: "15.6.5",
		505: "15.6.6",
	}

	return fmt.Sprintf(
		"https://tools.ietf.org/html/rfc9110#section-%s",
		codeSection[statusCode],
	)
}

// option is a type that can be used to configure a value.
type option interface {
	apply(*Problem)
}

// optionFunc is a function type that implements the Option interface.
type optionFunc func(*Problem)

// apply calls the OptionFunc.
func (f optionFunc) apply(opt *Problem) {
	f(opt)
}
